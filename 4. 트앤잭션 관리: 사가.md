# 트랜잭션 관리: 사가

### 이 장에서 다룰 핵심 내용

- 요즘 애플리케이션에 분산 트랜잭션이 잘 어울리지 않는 이유
- 사가 패턴을 마이크로서비스 아키텍처에 적용하여 데이터 일관성 유지
- 코레오그래피/오케스트레이션 방식으로 사가 편성
- 비격리 문제 조치 대책

이 장은 마이크로서비스 아키텍처가 트랜잭션 관리가 어려운 이유를 먼저 알아보고, 기존 분산 트랜잭션 관리 방식을 사용할 수 없는 이유를 설명한다. 그리고 사가로 데이터 일관성을 유지하는 방법을 살펴본 후, 사가를 편성하는 두 가지 기법을 차례로 소개한다. 코레오그래피는 중앙 제어 장치 없이 참여자가 각자 서로 이벤트를 교환하는 방식이고, 오케스트레이션은 중앙 제어 장치가 참여자가 해야 할 일을 지시하는 방식이다. 사가 간 격리가 되지 않아 발생하는 동시 비정상의 영향을 줄이가나 방지할 수 있는 대책도 알아본다.

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리

사가를 설명하기 전에 먼저 마이크로서비스 아키텍처에서 트랜잭션 관리가 어려운 이유를 알아본다.

### 4.1.1 분산 트랜잭션의 필요성

데이터가 여러 서비스에 흩어져 있는 마이크로서비스 아키텍처는 데이터 일관성을 보장하는게 복잡하다.

서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는 수단을 강구해야 한다.

### 4.1.2 분산 트랜잭션의 문제점

NoSQL DB와 현대 메시지 브로커(예: RabbitMQ, 아파치 카프카)는 분산 트랜잭션을 지원하지 않으므로 분산 트랜잭션이 필수라면 최근 기술은 상당수 포기할 수밖에 없다.

동기 IPC 형태라서 가용성이 떨어진다. 분산 트랜잭션은 참여한 서비스가 모두 가동 중이어야 커밋할 수 있다. 

지금까지 설명한 문제점 때문에 요즘 애플리케이션에는 잘 맞지 않다. 마이크로서비스 아키텍처에서 데이터 일관성을 유지하려면, 느슨하게 결합된 비동기 서비스 개념을 토대로 뭔가 다른 매커니즘이 절실하다. 이것이 바로 사가다.

### 4.1.3 데이터 일관성 유지: 사가 패턴

사가는 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 매커니즘이다. 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의한다. 사가는 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션이다.

시스템 작업은 사가의 첫 번째 단계를 시작한다. 어느 로컬 트랜잭션이 완료되면 이어서 그다음 로컬 트랜잭션이 실행된다. 비동기 메시징은 하나 이상의 사가 참여자가 일시 불능 상태인 경우에도 사가의 전체 단계를 확실히 실행시킬 수 있는 중요한 장점이 있다.

사가와 ACID 트랜잭션은 두 가지 중요한 차이점이 있다. 첫째, ACID 트랜잭션에 있는 격리성이 사가에는 없다. 둘째, 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 한다.

서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계를 트리거한다. 메시지를 통해 사가 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장하는 것이다. 메시지 수신자가 일시 불능 상태라면, 메시지 브로커는 다시 메시지를 전달할 수 있을 때까지 메시지를 버퍼링한다.

#### 사가는 보상 트랜잭션으로 변경분을 롤백한다.

사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가능하다. 즉, 보상 트랜잭션을 미리 작성해야 한다.

(n + 1)번째 사가 트랜잭션이 실패하면 이전 n개의 트랜잭션을 undo해야 한다. 비즈니스 규칙에 위배되어 어느 사가 단계에서 실패하면 사가는 보상 트랜잭션을 실행하여 이전 단계에서 발생한 업데이트를 undo한다.

사가는 트랜잭션이 진행되는 반대 방향으로 보상 트랜잭션을 실행한다. 

모든 단계에 보상  트랜잭션이 필요한 것은 아니다. 읽기 전용 단계나, 항상 성공하는 단계 다음에 이어지는 단계는 보상 트랜잭션이 필요없다.

실패할 가능성이 있는 단계 다음에 있는 트랜잭션은 **보상 트랜잭션**, 절대로 실패하지 않는 단계 다음에 있으면 **피봇 트랜잭션**, 항상 성공하기 때문에 **재시도 가능 트랜잭션**이 있다.

## 4.2 사가 편성

사가는 단계를 편성하는 로직으로 구성된다. 시스템 커맨드가 사가를 시작할 때 이 편성 로직은 첫 번째 사가 참여자를 정하여 로컬 트랜잭션 실행을 지시하고, 트랜잭션이 완료되면 그다음 사가 참여자를 호출하는 과정이 모든 단계가 실행될 때까지 반복된다. 도중 하나라도 로컬 트랜잭션이 실패하면 사가는 보상 트랜잭션을 역순으로 실행한다. 사가 편성 로직은 두 가지 종류가 있다.

- 코레오그래피: 의사 결정과 순서화를 사가 참여자에게 맡긴다. 사가 참여자는 주로 이벤트 교환 방식으로 통신한다.
- 오케스트레이션: 사가 편성 로직을 사가 오케스트레이터에 중앙화한다. 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시한다.

### 4.2.1 코레오그래피 사가

코레오그래피 방식은 사가 참여자가 할 일을 알려주는 중앙 편성자가 없다. 그 대신 사가 참여자가 서로 이벤트를 구독해서 그에 따라 반응하는 것이다.

#### 코레오그래피 스타일

**그림 4-4 확인**

사가 참여자는 서로 이벤트를 주고받으며 소통한다. 주문 서비스를 시작으로 각 참여자는 자신의 DB를 업데이트하고 다음 참여자를 트리거하는 이벤트를 발행한다.

코레오그래피 사가 참여자는 발행/구독 방식으로 소통한다.

#### 확실한 이벤트 기반 통신

코레오그래피 방식으로 사가를 수현하려면 두 가지 통신 이슈를 고려해야 한다. 첫째, 사가 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행하도로 해야 한다. 코레오그래피 사가는 단계별로 DB를 업데이트한 후 이벤트를 발행한다. 여기서 DB를 업데이트하는 작업과 이벤트를 발행하는 작업은 원자적으로 일어나야 한다. 따라서 사가 참여자가 서로 확실하게 통신하려면 트랜잭셔널 메시징을 사용해야 한다.

둘째, 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 한다. 해결책은 데이터를 매핑할 수 있도록 다른 사가 참여자가 상관관계 ID가 포함된 이벤트를 발행하는 것이다.

#### 코레오그래피 사가의 장단점

코레오그래피 사가는 다음과 같은 장점이 있다.

- 단순함: 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행한다.
- 느슨한 결합: 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못한다.

하지만 다음과 같은 단점도 있다.

- 이해하기 어렵다: 오케스트레이션 사가와 달리, 사가를 어느 한곳에 정의한 것이 아니라서 여러 서비스에 구현로직이 흩어져 있다. 어떤 사가가 어떻게 작동되는지 개발자가 이해하기 어려운 편이다.
- 서비스 간 순환 의존성: 참여자가 서로 이벤트를 구독하는 특성상, 순환 의존성이 발생하기 쉽다. 순환 의존성은 잠재적인 설계 취약점이다.
- 단단히 결합될 위험성: 사가 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다. 이를테면 회계 서비스는 소비자 신용카드를 과금/환불 처리하게 만드는 모든 이벤트를 구독해야 한다. 따라서 이 서비스는 주문 서비스에 구현된 주문 주기와 맞물려 업데이트되어야 하는 위험이 있다.

간단한 사가라면 코레오그래피 방식으로도 충분하지만 복잡한 사가는 아무래도 오케스트레이션 방식이 적합하다.

### 4.2.2 오케스트레이션 사가

오케스트레이션 사가에서는 사가 참여자가 할 일을 알려주는 오케스트레이터 클래스를 정의한다. 사가 오케스트레이터는 커맨드/비동기 응답 상호 작용을 하며 참여자와 통신한다. 즉, 사가 단계를 실행하기 위해 해당 참여자가 무슨 일을 해야 하는지 커맨드 메시지에 적어 보낸다. 사가 참여자가 작업을 마치고 응답 메시지를 오케스트레이터에 주면, 오케스트레이터는 응답 메시지를 처리한 후 다음 사가 단계를 어느 참여자가 수행할지 결정한다.

#### 오케스트레이션 스타일

**그림 4-6 확인**

#### 사가 오케스트레이터를 상태 기계로 모델링

상태 기계는 상태와 이벤트에 의해 트리거되는 상태 전이로 구성된다. 전이가 발생할 때마다 액션이 일어나는데, 사가의 액션은 사가 참여자를 호출하는 작용이다. 상태 간 전이는 사가 참여자가 로컬 트랜잭션을 완료하는 시점에 트리거되고, 로컬 트랜잭션의 상태와 결과에 따라 상태 전이를 어떻게 하고 어떤 액션을 취할지 결정된다. 상태 기계는 효율적으로 테스트할 수 있기 때문에 상태 기계를 이용하여 사가를 모델링하면 설계, 구현, 테스트를 더 쉽게 진행할 수 있습니다.

상태 기계는 다양한 상태 전이도 정의한다. 예) 승인/거부 상태

상태 기계의 초기 액션은 소비자 서비스에 소비자 확인 커맨드를 전송하는 것이다. 상태 기계는 사가 참여자의 여러 가지 응답에 따라 다양한 상태 전이를 거치면서 결국 승인/거부 두 상태 중 한 쪽으로 귀결된다.

#### 사가 오케스트레이션과 트랜잭셔널 메시징

오케스트레이션 사가는 DB를 업데이트하는 서비스와 메시지를 발행하는 서비스가 단계마다 있다. 사가 참여자는 자신의 DB를 업데이트한 후 응답 메시지를 보내는 식으로 커맨드 메시지를 처리한다. 그러면 다시 서비스는 사가 오케스트레이터 상태를 업데이트한 후 커맨드 메시지를 다음 사가 참여자에게 보낸다. 이런 식으로 참여자의 응답 서비스를 처리하는 것이다. 이때 서비스는 트랜잭셔널 메시지를 사용해서 DB 업데이트와 메시지 발행 작업을 원자적으로 처리해야 한다.

#### 오케스트레이션 사가의 장단점

오케스트레이션 사가는 다음과 같은 장점이 있다.

- 의존 관계 단순화: 오케스트레이터는 참여자를 호출하지만 참여자는 오케스트레이터를 호출하지 않으므로 순환 의존성이 발생하지 않는다. 즉, 오케스트레이터는 참여자에게 의존하지만 그 반대는 성립되지 않으므로 순환 의존성은 발생하지 않는다.
- 낮은 결합도: 각 서비스는 오케스트레이터가 호출하는 API를 구현할 뿐, 사가 참여자가 발행하는 이벤트는 몰라도 된다.
- 관심사를 더 분리하고 비즈니스 로직을 단순화: 사가 편성 로직이 사가 오케스트레이터 한곳에만 있으므로 도메인 객체는 더 단순해지고 자신이 참여한 사가에 대해서는 알지 못한다.

오케스트레이션도 단점은 있다. 비즈니스 로직을 오케스트레이터에 너무 많이 중앙화하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 할 일을 지시하는 모양새가 될 수도 있다. 이 문제는 오케스트레이터가 순서화만 담당하고 여타 비즈니스 로직은 갖고 있지 않도록 설계하면 해결된다.

아주 단순한 사가가 아니라면 가급적 오케스트레이션 방식을 권장한다.

## 4.3 비격리 문제

사가는 격리성이 빠져 있다. 실제로 사가의 한 트랜잭션이 커밋한 변경분을 다른 사가가 즉시 바라볼 수 있다. 이는 두 가지 문제를 야기한다. 첫째, 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기할 수 있다. 둘째, 한 사가가 업데이트 하기 이전 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 깨질 수 있다. 사가는 사실 ACD 트랜잭션으로 보아야 한다.

- 원자성: 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 undo해야 한다.
- 일관성: 서비스 내부의 참조 무결성은 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리한다.
- 지속성: 로컬 DB로 처리한다.

격리가 안 되면 DB 용어로 비정상이 나타날 가능성이 있다. 트랜잭션이 차례대로 실행되지 않는 것처럼 데이터를 읽고 쓰게 되는 현상이다. 그래서 사가를 동시 실행한 결과와 순차 실행한 결과가 달라질 수 있다.

하지만 실제로 성능 향상을 위해 격리 수준을 낮추어 개발하는 경우가 흔하다.

### 4.3.1 비정상 개요

비격리로 인한 비정상은 다음과 같이 정리할 수 있다.

- 소실된 업데이트: 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 쓴다.
- 더티 읽기: 사가 업데이트를 하지 않은 변경분을 다른 트랜잭션이나 사가가 읽는다.
- 퍼지/반복 불가능한 읽기: 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상. 다른 사가가 그 사이 업데이트를 했기 때문에 생기는 문제이다.

### 4.3.2 비격리 대책

개발자는 비격리로 인한 비정상을 방지하고 비즈니스에 미치는 영향을 최소화하는 방향으로 사가를 작성할 의무가 있다. `*_PENDING` 상태(예: APPROVAL_PENDING)도 이상 현상을 예방하는 전략 중 하나다. 주문 생성 사가처럼 주문을 업데이트하는 사가는 일단 주문을 `*_PENDING` 상태로 두고 시작한다. 현재 주문을 사가로 업데이트 하는 중이니 그에 맞게 행동하라고 다른 사가에게 알리는 것이다.

`*_PENDING`은 시멘틱 락 대책 기법의 일례이다.

- 시멘틱 락: 애플리케이션 수준의 락
- 교환적 업데이트: 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계한다.
- 비관적 관점: 사가 단계 순서를 재조정하여 비즈니스 리스크를 최소화한다.
- 값 다시 읽기: 데이터를 덮어 쓸 때 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 더티 쓰기를 방지한다.
- 버전 파일: 순서를 재조정할 수 있게 업데이트를 기록한다.
- 값에 의한: 요청별 비즈니스 위험성을 기준으로 동시성 매커니즘을 동적 선택한다.

#### 사가의 구조

사가는 다음 세 가지 트랜잭션으로 구성된다. **그림 4-8**

- 보상 기능 트랜잭션: 보상 트랜잭션으로 롤백 가능한 트랜잭션
- 피봇 트랜잭션: 사가의 진행/중단 지점. 피봇 트랜잭션이 커밋되면 사가는 완료될 때까지 실행된다. 피봇 트랜잭션은 보상 가능 트랜잭션, 재시도 가능한 트랜잭션 그 어느 쪽도 아니지만, 최종 보상 가능 트랜잭션 또는 최초 재시도 가능 트랜잭션이 될 수는 있다.
- 재시도 가능 트랜잭션: 피봇 트랜잭션 직후의 트랜잭션, 반드시 성공한다.

#### 대책: 시맨틱 락

보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는 대책이다. 레코드가 아직 커밋 전이라서 변경될지 모른다는 표시를 하는 것이다. 플래그를 세팅해서 다른 트랜잭션이 레코드에 접근하지 못하게 락을 걸어 놓거나, 다른 트랜잭션이 해당 레코드를 처리할 때 조심하도록 경고한다. 플래그는 재시도 가능 트랜잭션(사가 완료) 또는 보상 트랜잭션(사가 롤백)에 의해 해제된다.

락도 관리해야 하지만 잠금된 레코드를 어떻게 사가로 처리할지 사례별로(case-by-case) 결정해야 한다.

시맨틱 락을 사용하면 ACID 트랜잭션 고유의 격리 기능을 되살릴 수 있다. 같은 레코드를 업데이트하는 사가를 직렬화시킬 수 있어 프로그래밍 부담이 확 줄어들고, 클라이언트가 재시도해야 하는 부담도 덜 수 있다. 물론 애플리케이션에서 락을 관리하는 부담은 감수해야 한다. 또 데드락 감지 알고리즘을 구현해서 데드락이 발생하면 사가를 롤백시켜 데드락을 해소하고 재실행할 수 있게 조치해야 한다.

#### 대책: 교환적 업데이트

업데이트를 교환적으로, 즉 어떤 순서로도 실행 가능하게 설계하면 소실된 업데이트 문제를 방지할 수 있다. 

#### 대책: 비관점 관점

비관점 관점은 더티 읽기로 인한 비즈니스 리스크를 최소화하기 위해 사가 단계의 순서를 재조정하는 것이다.

#### 대책: 값 다시 읽기

값 다시 읽기는 소실된 업데이트를 방지하는 대책이다. 사가가 레코드를 업데이트하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것이다. 값을 다시 읽었더니 변경되었다면 사가를 중단하고 나중에 재시작한다. 이 대책은 일종의 낙관적 오프라인 락 패턴이다.

#### 대책: 버전 파일

버전 파일은 레코드에 수행한 작업을 하나하나 기록하는 대책이다. 즉, 비교환적 작업을 교환적으로 변환하는 방법이다.