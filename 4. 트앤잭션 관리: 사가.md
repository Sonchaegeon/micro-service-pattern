# 트랜잭션 관리: 사가

### 이 장에서 다룰 핵심 내용

- 요즘 애플리케이션에 분산 트랜잭션이 잘 어울리지 않는 이유
- 사가 패턴을 마이크로서비스 아키텍처에 적용하여 데이터 일관성 유지
- 코레오그래피/오케스트레이션 방식으로 사가 편성
- 비격리 문제 조치 대책

이 장은 마이크로서비스 아키텍처가 트랜잭션 관리가 어려운 이유를 먼저 알아보고, 기존 분산 트랜잭션 관리 방식을 사용할 수 없는 이유를 설명한다. 그리고 사가로 데이터 일관성을 유지하는 방법을 살펴본 후, 사가를 편성하는 두 가지 기법을 차례로 소개한다. 코레오그래피는 중앙 제어 장치 없이 참여자가 각자 서로 이벤트를 교환하는 방식이고, 오케스트레이션은 중앙 제어 장치가 참여자가 해야 할 일을 지시하는 방식이다. 사가 간 격리가 되지 않아 발생하는 동시 비정상의 영향을 줄이가나 방지할 수 있는 대책도 알아본다.

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리

사가를 설명하기 전에 먼저 마이크로서비스 아키텍처에서 트랜잭션 관리가 어려운 이유를 알아본다.

### 4.1.1 분산 트랜잭션의 필요성

데이터가 여러 서비스에 흩어져 있는 마이크로서비스 아키텍처는 데이터 일관성을 보장하는게 복잡하다.

서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는 수단을 강구해야 한다.

### 4.1.2 분산 트랜잭션의 문제점

NoSQL DB와 현대 메시지 브로커(예: RabbitMQ, 아파치 카프카)는 분산 트랜잭션을 지원하지 않으므로 분산 트랜잭션이 필수라면 최근 기술은 상당수 포기할 수밖에 없다.

동기 IPC 형태라서 가용성이 떨어진다. 분산 트랜잭션은 참여한 서비스가 모두 가동 중이어야 커밋할 수 있다. 

지금까지 설명한 문제점 때문에 요즘 애플리케이션에는 잘 맞지 않다. 마이크로서비스 아키텍처에서 데이터 일관성을 유지하려면, 느슨하게 결합된 비동기 서비스 개념을 토대로 뭔가 다른 매커니즘이 절실하다. 이것이 바로 사가다.

### 4.1.3 데이터 일관성 유지: 사가 패턴

사가는 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 매커니즘이다. 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의한다. 사가는 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션이다.

시스템 작업은 사가의 첫 번째 단계를 시작한다. 어느 로컬 트랜잭션이 완료되면 이어서 그다음 로컬 트랜잭션이 실행된다. 비동기 메시징은 하나 이상의 사가 참여자가 일시 불능 상태인 경우에도 사가의 전체 단계를 확실히 실행시킬 수 있는 중요한 장점이 있다.

사가와 ACID 트랜잭션은 두 가지 중요한 차이점이 있다. 첫째, ACID 트랜잭션에 있는 격리성이 사가에는 없다. 둘째, 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 한다.

서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계를 트리거한다. 메시지를 통해 사가 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장하는 것이다. 메시지 수신자가 일시 불능 상태라면, 메시지 브로커는 다시 메시지를 전달할 수 있을 때까지 메시지를 버퍼링한다.

#### 사가는 보상 트랜잭션으로 변경분을 롤백한다.

사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가능하다. 즉, 보상 트랜잭션을 미리 작성해야 한다.

(n + 1)번째 사가 트랜잭션이 실패하면 이전 n개의 트랜잭션을 undo해야 한다. 비즈니스 규칙에 위배되어 어느 사가 단계에서 실패하면 사가는 보상 트랜잭션을 실행하여 이전 단계에서 발생한 업데이트를 undo한다.

사가는 트랜잭션이 진행되는 반대 방향으로 보상 트랜잭션을 실행한다. 

모든 단계에 보상  트랜잭션이 필요한 것은 아니다. 읽기 전용 단계나, 항상 성공하는 단계 다음에 이어지는 단계는 보상 트랜잭션이 필요없다.

실패할 가능성이 있는 단계 다음에 있는 트랜잭션은 **보상 트랜잭션**, 절대로 실패하지 않는 단계 다음에 있으면 **피봇 트랜잭션**, 항상 성공하기 때문에 **재시도 가능 트랜잭션**이 있다.

## 4.2 사가 편성

사가는 단계를 편성하는 로직으로 구성된다. 시스템 커맨드가 사가를 시작할 때 이 편성 로직은 첫 번째 사가 참여자를 정하여 로컬 트랜잭션 실행을 지시하고, 트랜잭션이 완료되면 그다음 사가 참여자를 호출하는 과정이 모든 단계가 실행될 때까지 반복된다. 도중 하나라도 로컬 트랜잭션이 실패하면 사가는 보상 트랜잭션을 역순으로 실행한다. 사가 편성 로직은 두 가지 종류가 있다.

- 코레오그래피: 의사 결정과 순서화를 사가 참여자에게 맡긴다. 사가 참여자는 주로 이벤트 교환 방식으로 통신한다.
- 오케스트레이션: 사가 편성 로직을 사가 오케스트레이터에 중앙화한다. 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시한다.

### 4.2.1 코레오그래피 사가

코레오그래피 방식은 사가 참여자가 할 일을 알려주는 중앙 편성자가 없다. 그 대신 사가 참여자가 서로 이벤트를 구독해서 그에 따라 반응하는 것이다.

#### 코레오그래피 스타일

**그림 4-4 확인**

사가 참여자는 서로 이벤트를 주고받으며 소통한다. 주문 서비스를 시작으로 각 참여자는 자신의 DB를 업데이트하고 다음 참여자를 트리거하는 이벤트를 발행한다.

