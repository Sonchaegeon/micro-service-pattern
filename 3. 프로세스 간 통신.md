# 프로세스 간 통신

### 이 장에서 다룰 핵심 내용

- 다양한 통신 패턴 적용: 원격 프로시저 호출, 회로 차단기, 클라이언트 쪽 디스커버리, 자가 등록, 서버 쪽 디스커버리, 서드파티 등록, 비동기 메시징, 트랜잭셔널 아웃박스, 트랜잭션 로그 테일링, 발행기(publisher) 폴링
- 마이크로서비스 아키텍처에서 IPC의 중요성
- API 정의 및 발전
- 여러 가지 IPC와 각각의 트레이드오프
- 비동기 메시징으로통신하는 서비스의 장점
- 메시지를 DB 트랜잭션에 태워 확실하게 전송

마이크로서비스 아키텍처는 애플리케이션을 여러 개의 서비스로 구성하며, 서비스는 대부분 요청을 처리하기 위해 서로 협동한다. 서비스 인스턴스는 여러 머신에서 실행되는 프로세스 형태이므로 반드시 IPC를 통해 상호 작용해야 한다.

IPC 비중 = 모놀리식 < 마이크로서비스

## 3.1 마이크로서비스 아키텍처 IPC 개요

### 3.1.1 상호 작용 스타일

서비스 API에 알맞은 IPC를 선택하기 전에 클라이언트/서비스 간 상호 작용 스타일을 잘 살펴보면, 요건에서 벗어나는 일 없이 특정 IPC 기술의 세부 내용에 빠져 헤매는 일을 방지할 수 있다.

클라이언트/서비스 상호 작용 스타일은 두 가지 기준을 분류 할 수 있다.

1. 일대일/일대다 여부
   - 일대일: 각 클라이언트 요청은 정확히 한 서비스가 처리한다.
   - 일대다: 각 클라이언트 요청을 여러 서비스가 협동하여 처리한다.
2. 동기/비동기 여부
   - 동기: 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹 할 수 있다.
   - 비동기: 클라이언트가 블로킹하지 않는다. 응답은 즉시 전송괴지 않아도 된다. 

일대일 상호 작용 종류

- 요청/응답: 클라이언트는 서비스에 요청을 하고 응답을 기다린다. 클라이언트는 응답이 제때 도착하리라 기대하고 대기 도중 블로킹할 수 있다. 결과적으로 서비스가 서로 강하게 결합되는 상호 작용 스타일이다.
- 비동기 요청/응답: 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답한다. 클라이언트는 대기 중에 블로킹하지 않고, 서비스는 오랫동안 응답하지 않을 수 있다.
- 단방향 알림: 클라이언트는 서비스에 일방적으로 요청만 하고 서비스는 응답을 보내지 않는다.

일대다 상호 작용 종류

- 발행/구독: 클라이언트는 알림 메시지를 발행하고, 여기에 관심 있는 0개 이상의 서비스(즉, 관심 있는 서비스가 없는 경우도 있음)가 메시지를 소비한다.
- 발행/비동기 응답: 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다린다.

각 서비스마다 이런 상호 작용 스타일을 조합해서 사용하면 된다.

### 3.1.2 마이크로 서비스 API 정의

어떤 IPC를 선택하든, 서비스 API를 IDL(Inferface Definition Language, 인트페이스 정의 언어)로 정확하게 정의해야 한다. 선 설계 후 구현 방식으로 진행하면 클라이언트 니즈에 좀 더 부합한 서비스를 구축할 수 있다.

### 3.1.3 API 발전시키기

마이크로서비스 애플리케이션은 클라이언트를 다른 서비스 팀이 개발한 경우가 대부분이기 때문에 서비스 API를 변경하기가 무척 어렵다. 

#### 시멘틱 버저닝

시멘틱 버저닝 명세는 API 버거닝에 관한 유용한 지침서이다. 

이 명세에 따르면 버전 번호를 MAJOR.MINOR.PATCH 세 파트로 구성하고 다음 규칙에 따라 각각 증가시킨다.

- MAJOR: 하위 호환되지 않는 변경분을 API에 적용 시
- MINOR: 하위 호환되는 변경분을 API에 적용 시
- PATCH: 하위 호환되는 오류 수정 시

REST API라면 메이저 버전을 URL 경로의 첫 번째 엘리먼트로 쓸 수 있고, 메시징 기반의 서비스라면 이 서비스가 발행한 메시지에 버전 번호를 넣을 수 있다.

#### 하위 호환되는 소규모 변경

변경을 하더라도 가급적 하위 호환성을 보장하는 방향으로 해야 한다.

- 옵션 속성을 요청에 추가
- 속성을 응답에 추가
- 새 작업을 추가

이런 종류의 변경은 새 서비에 적용해도 기존 클라이언트 역시 별 문제없이 동작한다. 요청 속성이 누락되어도 서비스는 기본값을 제공하고, 서비스가 필요한 것보다 더 많은 속성을 응답하더라도 클라이언트는 간단히 무시해야 한다.

#### 중대한 대규모 변경

일시에 클라이언트를 강제로 업그레이드하는 것은 불가하므로 일정 기간 동안 서비스는 신구 버전 API를 모두 지원해야 한다.

버전 1 경로는 앞에 /v1/를, 버전 2 경로는 /v2/를 붙임으로 해결

### 3.1.4 메시지 포맷

대부분의 메시지는 데이터를 담고 있기 때문에 데이터 포맷은 중요한 설계 결정 항목이다. IPC 효율, API 가용성, 발전성에도 영향을 미친다.

### 텍스트 메시지 포맷

JSON, XML 등 텍스트 기반 포맷은 사람이 읽을 수 있고 자기 서술적 장점이 있다. 메시지 컨슈머는 자신이 관심 있는 값만 골라 쓰고 나머지는 그냥 무시하면 되므로 하위 호환성은 쉽게 보장된다.

텍스트 메시지 포맷의 단점은 메시지가 다소 길다는 사실이다. 따라서 효율/성능이 중요한 경우는 이진 포맷을 고려해 봄직하다.

#### 이진 메시지 포맷

이진 포맷은 종류가 다양하지만 포로토콜 버퍼와 아브로가 유명하다. 

아브로 컨슈머는 스키마를 알고 있어야 메시지를 해석할 수 있기 때문에 API 발전 측면에서는 프로토콜 버퍼가 더 용이하다.

## 3.2 동기 RPI 패턴 응용 통신

RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC이다. 메시징으로 통신하는 클라이언트와 달리 응답이 제때 도착하리라 가정한다.

클라이언트의 비즈니스 로직은 RPI 프록시 어댑터 클래스로 구현된 프록시 인터페이스를 호출한다. RPI 프록시 클래스가 서비스에 요청하면 RPI 서버 어댑터 클래스가 서비스 비즈니스 로직을 호출해서 요청을 처리한다.

프록시 인터페이스는 하부 통신 프로토콜을 캡슐화한다.

### 3.2.1 동기 RPI 패턴: REST

REST는 HTTP로 소통하는 IPC이다.

#### REST 성숙도 모델

- 레벨 0: 클라이언트는 서비스별로 유일한 URL 끝점에 HTTP POST 요청을 하여 서비스를 호출한다. 요청을 할 때마다 어떤 액션을 수행할지, 그 대상은 무엇인지 지정한다. 필요한 매개변수도 함께 전달한다.
- 레벨 1: 서비스는 리소스 개념을 지원한다. 클라이언트는 수행할 액션과 매개변수가 지정된 POST 요청을 한다.
- 레벨 2: 서비스는 HTTP 동사를 이용해서 액션을 수행하고, 요청 쿼리 매개변수 및 본문, 필요 시 매개변수를 지정한다. 덕분에 서비스는 GET 요청을 캐싱하는 등 웹 인프라를 활용할 수 있다.
- 레벨 3: 서비스를 HATEOAS(애플리케이션 상태 엔진으로서의 하이퍼미디어) 원칙에 기반하여 설계한다. HATEOAS는 GET 요청으로 변환된 리소스 표현형에 그 리소스에 대한 액션의 링크도 함께 태워 보내자는 생각이다. 가령 클라이언트는 GET 요청으로 주문 데이터를 조회하고 이때 반환된 표현형 내부 링크를 이용해서 해당 주문을 취소할 수도 있다. HATEOAS를 사용하면 하드 코딩한 URL을 클라이언트 코드에 욱여넣지 않아도 된다.

#### REST API

스웨거라는 오픈 소스 프로젝트를 발전시킨 Open API Specification이 REST IDL로서 널리 보급되었다. 스웨거는 REST API를 개발/문서화하는 도구 세트이다.

#### 요청 한 번으로 많은 리소스를 가져오기 어렵다.

REST 리소스는 Consumer, Order 같은 비즈니스 객체 중심이다. 순수 REST API라면 클라이언트는 적어도 2회요청(주문 1, 소비자 1)을 해야 한다. 왕복 횟수가 증가하고 지연 시간이 급증해서 곤란해진다.

문제 해결 방법은 클라이언트가 리소스를 획득할 때 연관된 리소스도 함께 조회하도록 API가 허락하는 것이다. 예를 들어 GET /orders/order-id-1345?expand=consumer처럼 쿼리 매개변수로 주문과 함께 반환될 연관 리소스를 지정하면 주문, 소비자를 한꺼번에 조회할 수 있다. 하지만 여기서 더 복잡해지면 효율이 떨어지고 구현 시간이 많이 소요되는 문제도 있다. 

GraphQL, Netflix Falcor 기술로 해결 가능

#### 작업을 HTTP 동사에 매핑하기 어렵다

PUT 사용 시 필수 요건인 멱등서이 보장되지 않는 업데이트도 있다. 해결 방법은 리소스의 특정 부위를 업데이트하는 하위 리소스를 정의하는 것이다. POST /orders/{orderId}/cancel, 주문 변경 끝점 POST /orders/{orderId}/revise를 두는 것이다. 동사를 URL 쿼리 매개변수로 지정하는 방법은 REST 답지 않아서 gRPC같은 REST 대체 기술이 점점 인기를 끌고 있다.

#### REST 장단점

장점

- 단순하고 익숙함
- HTTP API를 간편하게 테스트할 수 있음 (예: 포스트맨, curl)
- 요청/응답 스타일의 통신을 직접 지원한다.
- HTTP는 방화벽 친화적이다.
- 중간 브로커가 필요하지 않기 때문에 시스템 아키텍처가 단순해진다.

단점

- 요청/응답 스타일의 통신만 지원한다.
- 가용성이 떨어진다. 중간에서 메시지를 버퍼링하는 매개자 없이 클라이언트/서비스가 직접 통신하기 때문에 교환이 일어나는 동안 양쪽 다 실행 중이어야 한다.
- 서비스 인스턴스의 위치(URL)를 클라이언트가 알고 있어야 한다. 요즘 애플리케이션은 서비스 디스커버리 매커니즘을 이용해서 클라이언트가 서비스 인스턴스 위치를 찾을 수 있으므로 큰 단점은 아니다.
- 요청 한 번으로 여러 리소스를 가져오기 어렵다.
- 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 때가 많다.

### 3.2.2 동기 RPI 패턴: gRPC

gRPC는 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크이다. 또, gRPC는 이진 메시지 기반의 프로토콜이므로 서비스를 API 우선 방식으로 설계할 수밖에 없다. gRPC API는 프로토콜 버퍼 기반의 IDL로 정의하며, 프로토콜 버퍼 컴파일러로 클라이언트 쪽 스텁 및 서버 쪽 스켈레톤을 생성할 수 있다. 클라이언트/서버는 포로토콜 버퍼 포맷의 이진 메시지를 HTTP/2를 통해 교환한다.

gRPC API는 하나 이상의 서비스와 요청/응답 메시지 정의로 구성된다. 스트리밍 RPC도 지원

gRPC는 프로토콜 버퍼 메시지 포맷을 사용한다. 프로토콜 버퍼 메시지는 각 필드마다 번호가 매겨지고 타입 코드가 할당된다. 메시지 수신자는 자신이 필요한 필드만 추출하고 모르는 필드는 그냥 건너뛸 수 있기 때문에 하위 호환성을 유지하며 API를 발전시킬 수 있다.

#### gRPC 장단점

장점

- 다양한 업데이트 작업이 포함된 API를 설계하기 쉽다.
- 특히 큰 메시지를 교환할 때 콤팩트하고 효율적인 IPC이다.
- 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능하다.
- 다양한 언어로 작성된 클라이언트/서버 간 연동이 가능하다.

단점

- 자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API보다 더 많다.
- 구형 방화벽은 HTTP/2를 지원하지 않는다.

gRPC는 REST를 대체할 만한 유력한 방안이지만, REST처럼 동기 통신하는 메커니즘이라서 부분 실패 문제를 해결해야 한다.

### 3.2.3 부분 실패 처리: 회로 차단기 패턴

분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재한다.

부분 실패가 애플리케이션 전체에 전파되지 않도록 서비스를 설계해야 한다.

- 무응답 원격 서비스를 처리하기 위해 견고한 RPI 프록시를 설계한다.
- 원격 서비스가 실패하면 어떻게 조치할지 결정한다.

#### 견고한 RPI 프록시 설계

넷플릭스 기술 블로그를 보면 서비스가 다른 서비스를 동기 호출할 때 자기 스스로를 방어하는 방법이 명쾌하게 기술되어 있다.

- 네트워크 타임아웃: 응답 대기 중에 무한정 블로킹하면 안 되고 항상 타임아웃을 걸어 둔다. 이렇게 해야 리소스가 마냥 붙잡히지 않는다.
- 미처리 요청 개수 제한: 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정한다. 이 개수에 이르면 더 이상의 요청은 무의미하므로 즉시 실패 처리하는 것이 타당하다.
- 회로 차단기 패턴: 성공/실패 요청 개수를 지켜보다가 에러율이 주어진 임계치를 초과하면 그 이후 시도는 바로 실패 처리한다. 실패된 요청이 많다는 것은 서비스가 블능 상태고 더 이상의 요청은 무의미하다는 뜻이다. 타임아웃 시간 이후 클라이언트가 재시도해서 성공하면 회로 차단기는 닫힌다.

Netflix Hystrix는 이와 같이 다양한 패턴이 구현된 오픈 소스 라이브러리이다. JVM 환경이라면 Hystrix를 이용하여 RPI 프록시를 구현해 봄직하다.

#### 불능 서비스 복구

Hystrix 같은 라이브러리는 부분적인 솔루션에 불과하다. 무응답 원격 서비스를 어떻게 복구하면 좋을지는 그때그때 상황에 맞게 판단해야 한다.

부분 실패 시 미리 정해진 기본값이나 캐시된 응답 등 대체 값(fallback value)을 반환하는 방법도 있다.

### 3.2.4 서비스 디스커버리

요즘 클라우드 기반의 마이크로서비스 어플리케이션은 네트워크 위치가 훨씬 동적이라서 이를 식별하는 일이 결코 간단하지 않다.

서비스 인스턴스마다 네트워크 위치가 동적 배정되고, 서비스 인스턴스는 자동 확장, 실패, 업그레이드 등 여러 가지 사유로 계속 달라지므로 클라이언트 코드는 서비스 디스커버리를 사용할 수 밖에 없다.

#### 서비스 디스커버리 개요

서비스 IP 주소가 정적으로 구성된 클라이언트 대신 서비스 디스커버리 매커니즘을 사용해야 한다. 핵심은 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리이다.

서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리가 업데이트된다. 클라이언트가 서비스를 호출하면 우선 서비스 디스커버리가 서비스 레지스트리에서 사용 서비스 인스턴스 목록을 가져오고, 그중 한 서비스로 요청을 라우팅한다.

서비스 디스커버리는 주로 다음 두 가지 방법으로 구현한다.

- 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용한다.
- 배포 인프라로 서비스 디스커버리를 처리한다.

#### 애플리케이션 수준의 서비스 디스커버리 패턴 적용

서비스 인스턴스는 자신의 네트워크 위치를 서비스 레지스트리에 등록하고, 서비스 클라이언트는 이 서비스 레지스트리로부터 전체 서비스 인스턴스 목록을가져와 그중 한 인스턴스로 요청을 라우팅한다. **그림 3-5 확인**

첫째, 자가 등록(self registration) 패턴이다. 서비스 인스턴스는 자신의 네트워크 위치를 서비스 레지스트리 등록 API를 호출해서 등록한다. 헬스 체크 URL을 제공하는 서비스도 있고, 서비스 인스턴스가 자신이 전에 등록한 네트워크 위치가 만료되지 않도록 주기적으로 `heartbeat` API를 호출해야 하는 서비스 레지스트리도 있다.

둘째, 클라리언트 쪽 디스커버리 패턴이다. 클라이언트는 서비스를 호출할 때 먼저 서비스 레지스트리에 서비스 인스턴스 목록을 요청해서 넘겨받는다(이 목록을 캐시하면 성능을 높일 수 있다). 그런 다음 서비스 클라이언트는 라운드-로빈이나 랜덤같은 부하 분산 알고리즘을 이용하여 서비스 인스턴스를 선택한 후 요청을 전송한다.

스프링 클라우드 기반의 서비스는 유레카에 자동 등록되며, 스프링 클라우드 기반의 클라이언트는 유레카를 기본 서비스 디스커버리로 사용한다.

애플리케이션 수준의 서비스 디스커버리는 다양한 플랫폼에 서비스가 배포된 경우에도 처리 가능한 장점이 있다. 쿠버네티스에 기반한 서비스 디스커버리는 쿠버네티스 내부에서만 동작하지만 유레카를 이용하는 애플리케이션 수준의 디스커버리는 두 환경 모두 잘 동작한다.

그러나 사용하는 언어(즉, 프레임워크)에 맞는 서비스 디스커버리 라이브러리가 필요한 단점도 있다.

#### 플렛폼에 내장된 서비스 디스커버리 패턴 적용

도커나 쿠버네티스 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 매커니즘이 탑재되어 있다. 서비스 클라이언트가 DNS명/VIP를 요청하면 배포 플랫폼이 알아서 가용 서비스 인스턴스 중 하나로 요청을 라우팅한다. 배포 플랫폼이 서비스 등록, 서비스 디스커버리, 요청 라우팅을 전부 관장하는 것이다. **그림 3-6 확인**

서비스 IP 주소를 추적하는 서비스 레지스트리는 배포 플랫폼에 내장되어 있다.

이 방식은 다음 두 패턴을 접목시킨 것이다.

- 서드파티 등록 패턴: 서비스가 자신을 서비스 레지스트리에 등록하는 것이 아니라, 배포 플랫폼의 일부인 등록시(registrar)라는 서드파티가 이 작업을 대행한다.
- 서버 쪽 디스커버리 패턴: 클라이언트가 서비스 레지스트리를 질의하지 않고 DNS명을 요청한다. 그러면 서비스 레지스트리를 쿼리하고 요청을 부하 분산하는 요청 라우터로 해석된다.

플랫폼에서 기본 제공된 서비스 디스커버리를 사용하면 서비스 디스커버리를 모두 배포 플랫폼이 알아서 처리하므로 아주 편리하다. 서비스 디스커버리 관련 코드는 클라이언트/서비스 어느 쪽에도 없기 때문에 서비스 개발 언어와 상관없이 모든 클라이언트/서비스에 곧바로 적용할 수 있다.

물론 단점도 있다. 가령 쿠버네티스에 기반한 디스커버리는 오직 쿠버네티스로 배포한 서비스에만 적용된다. 이런 한계점은 있지만 가능한 한 플랫폼에서 제공되는 서비스 디스커버리를 사용할 것을 권장한다.

## 3.3 비동기 메시징 패턴 응용 통신

메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식이다. 비동기 통신을 하기 때문에 클라이언트가 응답을 기다리며 블로킹하지 않는다. 클라이언트는 응답을 바로 받지 못할 것이라는 전제하에 작성한다.

### 3.3.1 메시징 개요

메시지는 메시지 채널을 통해 교환된다. 송신자(애플리케이션 또는 서비스)가 채널에 메시지를 쓰면 수신자(애플리케이션 또는 서비스)는 채널에서 메시지를 읽는다.

#### 메시지

메시지는 header와 body로 구성된다. header에는 송신된 데이터에 관한 메타데이터에 해당하는 키/값들로 구성된다. body는 실제로 송신할 텍스트 또는 이진 포맷의 데이터이다.

메시지의 종류는 다양하다.

- 문서: 데이터만 포함된 제네릭한 메시지(예: 커맨드에 대한 응답). 메시지를 어떻게 해석할지는 수신자가 결정한다.
- 커맨드: RPC 요청과 동등한 메시지. 호출할 작업과 전달할 매개변수가 지정되어 있다.
- 이벤트: 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 이벤트는 대부분 도메인 객체의 상태 변화를 나타내는 도메인 이벤트이다.

#### 메시지 채널

메시지는 채널을 통해 교환된다. 송신자가 채널에 보낼 수 있는 메시지와 수신자가 채널에서 받을 수 있는 메시지의 개수는 무제한이다. **그림 3-7 확인**

채널은 두 종류가 있다.

- 점대점 채널: 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달한다. 앞서 설명한 일대일 상호작용 스타일의 서비스가 이 채널을 사용한다(예: 커맨드 메시지).
- 발행-구독 채널: 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달한다. 앞서 설명한 일대다 상호 작용 스타일의 서비스가 이 채널을 사용한다(예: 이벤트 메시지).

### 3.3.2 메시징 상호 스타일 구현

메시징은 3.1.1절에서 상호 작용 스타일을 모두 지원할 만큼 아주 유연하다. 스타일에 따라 메시징에서 직접 구현 가능한 것도 있고, 메시징을 토대로 구현해야 하는 것도 있다.

#### 요청/응답 및 비동기 요청/응답

요청/응답은 서비스가 즉시 응답할 것이라고 클라이언트가 기대하지만 비동기 요청/응답은 클라이언트가 그런 기대를 하지 않는다. 메시징은 원래 성격 자체가 비동기적이라서 비동기 요청/응답만 제공하지만 응답을 수신할 때까지 클라이언트를 블로킹할 수도 있다.

클라이언트/서비스는 한 쌍의 메시지를 주고 받는 비동기 요청/응답 스타일로 상호 작용한다. **그림 3-8 확인**

클라이언트는 서비스가 어디로 응답 메시지를 보내야 하는지 알려 주고 이렇게 받은 응답 메시지는 요청과 짝이 맞아야 한다. 클라이언트는 `MessageId` 및 응답 채널이 헤더에 명시된 커맨드 메시지를 보내고, 서버는 `MessageId`와 값이 동일한 `CorrelationId`가 포함된 응답 메시지를 지정된 응답 채널에 쓰면 된다. 클라이언트는 이 `CorrelationId`를 이용하여 응답 메시지와 요청을 맞추어 볼 수 있다.

#### 단방향 알림

서비스가 소유한 점대점 채널로 클라이언트가 메시지(커맨드 메시지)를 보내면, 서비스는 이 채널을 구독해서 메시지를 처리하는 구조이다. 물론 단방향이므로 서비스는 응답을 반환하지 않는다.

#### 발행/구독

메시징은 발행/구독 스타일의 상호 작용을 기본 지원한다. 클라이언트는 여러 컨슈머가 읽는 발행/구독 채널에 메시지를 발행하고, 서비스는 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행한다. 이렇게 도메인 이벤트를 발행한 서비스는 해당 도메인 클래스의 이름을 딴 발행/구독 채널을 소유한다. 서비스는 자신이 관심있는 도메인 객체의 이벤트 채널을 구독한다.

#### 발행/비동기 응답

발행/비동기 응답 스타일은 발행/구독과 요청/응답의 엘리먼트를 조합한 고수준의 상호 작용 스타일이다. 클라이언트는 응답 채널 헤더가 명시된 메시지를 발행/구독 채널에 발행하고, 컨슈머는 `CorrelationId`가 포함된 응답 메시지를 지정된 응답 채널에 쓴다. 클라이언트는 이 `CorrelationId`로 응답을 취합하여 응답 메시지와 요청을 맞추어 본다.

비동기 API로 작업을 호출하는 서비스에는 요청용 메시지 채널이 있고, 이벤트를 발행하는 서비스는 이벤트 메시지 채널에 이벤트를 발행할 것이다.

### 3.3.3 메시징 기반 서비스의 API 명세 작성

서비스의 비동기 API 명세에는 메시지 채널명, 각 채널을 통해 교환되는 메시지 타입과 포맷을 명시하고, 메시지 포맷은 JSON, XML, 프로토콜 버퍼 등 표준 포맷으로 기술해야 한다. **그림 3-9 확인**

#### 비동기 작업 문서화

서비스 작업은 두 가지 상호 작용 스타일 중 하나로 호출할 수 있다.

- 요청/비동기 응답 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷, 서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성된다.
- 단방향 알림 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성된다.

서비스는 요청/비동기 응답, 단방향 알림 모두 동일한 요청 채널을 사용할 수 있다.

#### 발행 이벤트 문서화 

이런 스타일의 API 명세는 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성된다.

### 3.3.4 메시지 브로커

메시징 기반의 애플리케이션은 대부분 메시지 브로커를 사용한다. 메시지 브로커는 서비스가 서로 통신할 수 있게 해주는 인프라 서비스이다. **그림 3-10 확인**

#### 브로커리스 메시징

브로커리스 아키텍처의 서비스는 메시지를 서로 직접 교환한다. ZeroMQ는 잘 알려진 브로커리스 메시징 기술이다.

브로커리스 아키텍처는 다음과 같은 장점이 있다.

- 송신자가 보낸 메시지가 브로커를 거쳐 수신자로 이동하는 것이 아니라, 송신자에서 수신자로 직접 전달되므로 네트워크 트래픽이 가볍고 지연시간이 짧다.
- 메시지 브로커가 성능 병목점이나 SPOF(Single Point Of Failure, 단일 장애점)가 될 일이 없다.
- 메시지 브로커를 설정/관리할 필요가 없으므로 운영 복잡도가 낮다.

다음과 같은 중요한 단점도 있다.

- 서비스가 서로의 위치를 알고 있어야 하므로 서비스 디스커버리 메커니즘 중 하나를 사용해야 한다.
- 메시지 교환시 송신자/수신자 모두 실행 중이어야 하므로 가용성이 떨어진다.
- 전달 보장 같은 메커니즘을 구현하기가 더 어렵다.

이런 한계 때문에 엔터프라이즈 애플리케이션은 대부분 메시지 브로커 기반의 아키텍처를 사용한다.

#### 브로커 기반 메시징 개요

메시지 브로커는 모든 메시지가 지나가는 중간 지점이다. 메시지 브로커의 가장 큰 장점은 송신자가 컨슈머의 네트워크 위치를 몰라도 된다는 것이다. 또 컨슈모가 메시지를 처리할 수 있을 때까지 메시지 브로커에 메시지를 버퍼링 할 수 있다.

메시지 브로커 제품은 다양하다.

- ActiveMQ
- RabbitMQ
- Apache Kafka

AWS Kinesis, AWS SQS 등 클라우드 기반의 메시징 서비스도 있다.

메시지 블커를 선택할 때에는 다음 항목을 잘 검토해야 한다.

- 프로그래밍 언어 지원 여부: 다양한 프로그래밍 언어를 지원할수록 좋다.
- 메시징 표준 지원 여부: AMQP나 STOMP 등 표준 프로토콜을 지원하는 제품
- 메시지 순서: 메시지 순서가 유지되는가?
- 전달 보장: 어떤 종류의 전달 보장을 하는가?
- 영속화: 브로커가 고장 나도 문제가 없도록 메시지를 디스크에 저장하는가?
- 내구성: 컨슈머가 메시지 브로커에 다시 접속할 경우, 접속이 중단된 시간에 전달된 메시지를 받을 수 있나?
- 확장성: 얼마나 확장성이 좋은가?
- 지연 시간: 종단 간 지연 시간은 얼마나 되나?
- 경쟁사 컨슈머: 경쟁사의 컨슈머를 지원하는가?

어던 브로커 제품이 최적인지는 애플리케이션 요건에 따라 다르다.

하지만 메시징 순서 유지 및 확장성은 필수 요건이다.

#### 메시지 브로커로 메시지 채널 구현

메시지 채널은 메시지 브로커마다 구현 방식이 조금씩 다르다.

| 메시지 브로커             | 점대점 채널     | 발행-구독 채널                    |
| ------------------------- | --------------- | --------------------------------- |
| JMS                       | 큐              | 토픽                              |
| Apache Kafka              | 토픽            | 토픽                              |
| AMQP 브로커(예: RabbitMQ) | 익스체인지 + 큐 | 팬아웃 익스체인지, 컨슈머 개별 큐 |
| AWS Kinesis               | 스트림          | 스트림                            |
| AWS SQS                   | 큐              | -                                 |

점대점 채널만 지원하는 AWS SQS를 제외한 나머지 메시지 브로커들은 점대점, 발행/구독 채널을 모두 지원한다.

#### 브로커 기반 메시징의 장단점

브로커 기반의 메시징은 여러모로 장점이 많다.

- 느슨한 결합: 클라이언트는 적절한 채널에 그냥 메시지를 보내는 식으로 요청한다. 클라이언트는 서비스 인스턴스를 몰라도 되므로 서비스 인스턴스 위치를 알려 주는 디스커버리 메커니즘도 필요 없다.
- 메시지 버퍼링: 메시지 브로커는 처리 가능한 시점까지 메시지를 버퍼링한다. HTTP 같은 동기 요청/응답 프로토콜을 쓰면 교환이 일어나는 동안 클라이언트/서비스 양쪽 모두 가동 중이어야 하지만 메시징을 쓰면 컨슈머가 처리할 수 있을 때까지 그냥 큐에 메시지가 쌓인다. 덕분에 온라인 상점에서 주문 이행 시스템이 느려지거나 불능 상태에 빠지는 사고가 발생해도 컨슈머는 주문을 계속 접수할 수 있다. 그냥 언젠가는 처리되겠거니 간주하고 메시지를 차곡차곡 쌓아 두는 것이다.
- 유연한 통신: 메시징은 지금까지 설명한 모든 상호 작용 스타일을 지원한다.
- 명시적 IPC: RPC 메커니즘은 원격 서비스가 마치 자신이 로컬 서비스인 양 호출을 시도한다. 하지만 물리 법칙상으로도 그렇고 부분 실패할 가능성이 있기 때문에 사실 서비스와는 완전히 다르다.

메시징의 단점은 다음과 같다.

- 성능 병목 가능성: 메시지 브로커가 성능 병목점이 될 위험이 있다. 하지만 다행히 메시지 브로커는 대부분 확장이 잘 되도록 설계되어 있다.
- 단일 장애점 가능성: 메시지 브로커는 가용성이 높아야 한다. 그렇지 않으면 시스템 신뢰성에 흠이 갈 수 있다. 다행히 요즘 브로커는 대부분 고가용성이 보장되도록 설계되었다.
- 운영 복잡도 부가: 메시징 시스템 역시 설치, 구성, 운영해야 할 시스템 컴포넌트이다.

### 3.3.5 수신자 경합과 메시지 순서 유지

다슨 서비스가 create 메시지를 처리하기도 전에 delete 메시지를 처리하면 망한다. 그래서 Apache Kafka, AWS Kinesis 등 요즘 메시지 브로커는 샤딩된 채널을 이용한다. **그림 3-11 확인**

솔루션은 다음 세 부분으로 구성된다.

1. 샤딩된 채널은 복수의 샤드로 구성되며, 각 샤드는 채널처럼 작동한다.
2. 송신자는 메시지 헤더에 샤드 키(보통 무작위 문자열 또는 바이트)를 지정한다. 메시지 브로커는 메시지를 샤드 키별로 샤드/파티션에 배정한다. 예를 들어 샤드 키 해시 값을 샤드 개수로 나눈 나머지를 계산해서 샤드를 선택하는 식이다.
3. 메시징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급한다(Apache Kafka 용어로 컨슈머 그룹이라고 한다). 메시지 브로커는 각 샤드를 하나의 수신자에 배정하고, 수신자가 시동/종료하면 샤드를 재배정한다.