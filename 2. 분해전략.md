# 분해 전략

### 이 장에서 다룰 핵심 내용

- 소프트웨어 아키텍처의 정의와 중요성
- 분해 패턴을 적용하여 비즈니스 능력 및 하위 도메인별로 애플리케이션을 서비스로 분해
- DDD의 경계 컨텍스트 개념을 활용하여 복잡하게 얽힌 데이터를 분해하기 더 쉽게 풀기

마이크로서비스 아키텍처의 핵심과제는 애플리케이션을 기능에 따라 여러 서비스로 분해하는 문제이다. 결국 이 아키텍처의 출발점이자, 가장 중요한 요소는 서비스를 어떻게 정의하느냐 하는 것이다.

## 2.1 마이크로서비스 아키텍처란 무엇인가?

아키텍쳐가 중요한 이유는 소프트웨어의 품질 속성, 즉 '~성(~ilities)'으로 끝나는 지표가 아키텍처에 의해 결정되기 때문이다. 곧 배우는 마이크로서비스 아키텍처는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍처 스타일이다.

### 2.1.1 소프트웨어 아키텍처의 정의와 중요성

#### 소프트웨어 아키텍처의 정의

Len Bass와 그가 이끄는 소프트웨어 공학 연구소 직원들이 내린 정의를 참고하자면 다음과 같다.

> 컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트와 그들 간의 관계 그리고 이 둘의 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다.

다소 추상적인 문구이지만, 핵심은 애플리케이션 아키텍처가 여러 파트(엘리먼트)로의 분해와 이런 파트 간의 관계(연관성)라는 것이다. 분해가 중요한 이유는 다음 두 가지와 같다.

- 업무(labor)와 지식(knowledge)을 분리한다. 덕분에 전문 지식을 보유한 사람들(또는 여러 팀)이 함께 생산적으로 애플리케이션 작업을 할 수 있다.
- 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힌다.

#### 소프트웨어 아키텍처의 4+1 뷰 모델

Phillip Krutchen은 소프트웨어 아키텍처가 4+1 이라고 기술한 논문을 발표 했다. 4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의한다. 각 뷰는 아키텍처의 특정한 측면을 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.

**그림 2-1 확인**

각 뷰의 목적은 다음과 같다.

- 논리 뷰(logical view): 개발자가 작성한 소프트웨어 엘리먼트, 객체 지향 언어라면 클래스 패키지가 해당되며 결국 상속(inheritance), 연관(association), 의존(depends-on) 등 클래스와 패키지의 관계를 말한다.
- 구현 뷰(implementation view): 빌드 시스템의 결과물, 모듈(패키징된 코드)과 컴포넌트(하나 이상의 모듈로 구성된 실행/배포 가능 단위)로 구성된다. 자바에서 모듈은 보통 JAR 파일, 컴포넌트는 WAR 파일이나 실행 가능한 JAR 파일이다. 모듈 간 디펜던시와 컴포넌트/모듈 간 조합 관계도 이 뷰에 포함된다.
- 프로세스 뷰(process view): 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고, **[IPC](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=green187&logNo=110130416319)**는 프로세스 간 관계를 나타낸다.
- 배포 뷰(deployment view): 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 (물리 또는 가상) 머신 및 프로세스고, 머신 간의 관계가 바로 네트워킹이다. 프로세스와 머신사이의 관계도 이 뷰에서 기술된다.

4뷰 외에도 뷰를 구동시키는 시나리오가 있다. 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술한다.

정리하자면, 4+1 뷰 모델은 애플리케이션 아키텍처를 명쾌하게 표현하는 수단이다. 4뷰는 중요한 아키텍처 측면을, 시나리오는 뷰의 여러 엘리먼트가 협동하는 과정을 명시한다.

#### 아키텍처의 중요성

애플리케이션 요건은 크게 두 가지 종류로 나뉜다. 첫째, 애플리케이션이 해야 할 일을 정의한 기능 요건이다. 이 기능 요건과 아키텍처는 거의 무관하다. 어느 아키텍처든 기능 구현은 가능하기 때문!

둘째, 이른바 '~성'으로 끝나는 서비스 품질 요건이다. 아키텍처는 바로 이 요건을 충족시킬 수 있게 설계해야 하므로 아주 중요하다. 서비스 품질 요건은 확장성, 신뢰성 같은 런타임 품질 외에도 관리성, 테스트성, 베포성처럼 개발 시점의 품질도 해당된다. 애플리케이션 아키텍처를 어떻게 선택하느냐에 따라 이런 품질 요건을 얼마나 충족할 수 있을지 결정된다.

### 2.1.2 아키텍처 스타일 개요

소프트웨어 아키텍처 지식 체계의 선구자인 David Garlan과 Mary Shaw는 아키텍처 스타일을 이렇게 정의한다고 한다.

> 아키텍처 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다. 좀 더 구체적으로 말하면, 아키텍처 스타일은 그 스타일로 만든 인스턴스에서 사용 가능한 컴포넌트와 커넥터의 vocabulary(용어집), 그리고 이들을 조합할 수 있는 제약 조건을 결정한다.

| 아키텍처       | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| 모놀리식       | 구현 뷰를 하나의 컴포넌트로 구성한 아키텍처 스타일           |
| 마이크로서비스 | 애플리케이션을 느슨하게 결합된 여러 서비스로 구성하는 아키텍처 스타일 |

#### 계층화 아키텍처 스타일

계층마다 명확히 정의된 역할을 분담하여, 계층간 디펜던시는 아키텍처로 제한한다. 따라서 어떤 계층은 바로 하위에 있는 계층에만 의존하거나, 하위에 위치한 어느 한 계층에 의존한다.

3계층 아키텍처가 바로 계층화 아키텍처를 논리 뷰에 적용한 사례로, 애플리케이션 클래스를 다음 세 계층으로 구성한 아키텍처이다.

- 표현 계층(presentation layer): 사용자 인터페이스 또는 외부 API가 구현된 계층
- 비즈니스 로직 계층(business logic layer): 비즈니스 로직이 구현된 계층
- 영속화 계층(persistence layer): DB 상호 작용 로직이 구현된 계층

하지만 계층화 아키텍처는 몇 가지 중요한 흠이 있다.

- 표현 계층이 하나뿐이다: 애플리케이션을 호출하는 시스템이 하나밖에 없을까?
- 영속화 계층이 하나뿐이다: 애플리케이션이 상호작용하는 DB가 정말 하나뿐일까?
- 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다: 이론적으로 이런 디펜던시 때문에 DB 없이 비즈니스 로직을 테스트하는 것은 불가능하다.

육각형 아키텍처는 이런 문제점을 해결하고자 고안되었다.

#### 육각형 아키텍처 스타일

**그림 2-2 확인**

육각형 아키텍처는 논리 뷰를 비즈니스 로직 중심으로 구성한다. 애플리케이션에 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터들과 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터들을 둔다. 비즈니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 이 아키텍처의 가장 중요한 특장점이다.

비즈니스 로직에는 하나 이상의 포트가 있다. 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된 작업이다. 가령 자바라면 인터페이스가 포트. 포트 종류는 인바운드/아웃바운드 두 가지이다. 인바운드 포트는 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을 호출한다(예: 서비스의 퍼블릭 메서드가 정의된 서비스 인터페이스). 아웃바운드 포트는 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것이다(예: 데이터 접근 작업이 정의된 repository interface).

인바운드 어댑터는 외부에서 들어온 요청을 인바운드 포트를 호출해서 처리한다(예: REST endpoint, 웹 페이지가 구현된 스프링 MVC 컨트롤러, 메시지를 구독하는 메시지 브로커 클라이언트).

아웃바운드 어댑터는 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해서 처리한다(예: DB 작업이 구현된 DAO 클래스, 원격 서비스를 호출하는 프록시 클래스).

육각형 아키텍처 스타일의 가장 큰 장점은 비즈니스 로직에 있던 표현/데이터 접근 로직이 어댑터와 분리되었기 때문에 비즈니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다는 점이다.

육각형 아키텍처는 마이크로서비스 아키텍처를 이루는 각 서비스 아키텍처를 기술하는 가장 좋은 방법이다.

### 2.1.3 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다.

#### 서비스란 무엇인가?

서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트이다.

서비스 API는 내부 구현 상세를 캡슐화한다. 모놀리스와 달리 개발자는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없으므로 마이크로서비스 아키텍처에서 애플리케이션 모듈성은 보장된다.

각각의 마이크로서비스는 자체 아키텍처를 갖고 있기 때문에 기술 스택을 독자적으로 구축할 수 있지만, 대부분 육각형 아키텍처 형태를 취한다. 

#### 느슨한 결합

느슨하게 결합된 서비스는 마이크로서비스 아키텍처의 주요 특성 중 하나이다. 느슨하게 결합된 서비스는 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과가 있다. 무엇보다 개발자가 서비스를 이해하고, 변경하고, 테스트하기가 더 쉽다.

서비스는 느슨하게 결합되고 API를 통해서만 동작하기 때문에 서비스가 직접 DB와 통신하는 일은 불가능하다.

#### 공유 라이브러리의 역할

마이크로서비스 아키텍처에 공유 라이브러리를 사용하고픈 유혹에 빠지기 쉬운데, 서비스 코드 중복을 줄이는 것은 좋지만 의도치 않은 서비스 간 결합도를 유발하지 않도록 조심해야 한다.

변경 가능성이 조금이라도 있는 기능이라면 별도의 서비스로 구현하는 것이 낫다.

#### 서비스 규모는 별로 중요하지 않다.

크기보다는 작은 팀이 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계해야 한다.

대규모 팀을 꾸려야 하거나 서비스를 테스트하는 시간이 너무 오래 걸리면 팀과 서비스를 분할해야 한다. 다른 서비스의 변경분 때문에 내가 맡은 서비스도 계속 바꾸어야 한다거나, 내 서비스 때문에 다른 서비스가 바뀌어야 한다면 서비스가 느슨하게 결합되지 않았다는 반증이다.

마이크로서비스 아키텍처를 고민 중이라면 먼저 현재 애플리케이션의 서비스를 어떻게 식별하고 서비스를 서로 협동시킬지 결정해야한다.

## 2.2 마이크로서비스 아키텍처 정의

아키텍처를 정의하는 순서

1. 애플리케이션 요건을 핵심 요청으로 추출
2. 어떻게 여러 서비스로 분해할지 결정
3. 서비스별로 API를 정의하는 일

분해 과정에는 장애물이 많다.

1. 네트워크 지연
   - 서비스 간 왕복이 너무 잦아 실제로 분해할 수 없는 경우도 있다.
2. 서비스 간 동기 통신으로 인해 가용성이 떨어짐
   - 자기 완비형 서비스로 해결
3. 여러 서비스에 걸쳐 데이터 일관성을 지키는 용건
   - 사가로 해결
4. 애플리케이션 도처에 숨어 있는 만능 클래스
   - DDD 개념을 활용해서 제거

### 2.2.1 시스템 작업 식별

시스템 작업은 두 단계 프로세스를 거쳐 애플리케이션 요건으로부터 도출된다. 1단계는 고수준 도메인 모델을 생성하는 과정이고, 2단계는 시스템 작업을 도메인 모델로 정의하는 과정이다.

#### 고수준 도메인 모델 생성

먼저 고수준의 애플리케이션 도메인 모델을 대략 그려 본다.

주문하기 스토리

```
전제(Given)
	소비자가 있다.
	음식점이 있다.
	음식점은 서비자의 주소로 제시간의 음식을 배달할 수 있다.
	주문 총액이 음식점의 최소 주문량 조건에 보합한다.
조건(When)
	소비자가 음식점에 음식을 주문한다.
결과(Then)
	소비자 신용카드가 승인된다.
	주문이 PENDING_ACCEPTANCE 상태로 생성된다.
	생성된 주문이 소비자와 연관된다.
	생성된 주문이 음식점과 연관된다.
```

주문 접수 스토리

```
전체(Given)
	현재 주문은 PENDING_ACCEPTANCE 상태다.
	주문 배달 가능한 배달원이 있다.
조건(When)
	주문을 접수한 음식점은 언제까지 음식을 준비할 수 있다고 약속한다.
결과(Then)
	주문 상태가 ACCEPTED로 변경된다.
	주문의 promiseByTime 값을 음식점이 준비하기로 약속한 시간으로 업데이트된다.
	주문을 배달할 배달원을 배정한다.
```

도메일 모델의 주요 클래스는 **그림 2-7 확인**

#### 시스템 작업 정의

애플리케이션이 어떤 요청을 처리할지 식별하는 단계이다.

시스템 작업은 크게 다음 두 종류로 나뉜다.

- 커멘드: 데이터 생성, 수정, 삭제(CUD)
- 쿼리: 데이터 읽기(R)

커맨드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클래스로 정의한다. 이 명세는 작업 호출 시 충족되어야 할 선행 조건, 작업 호출 후 충족되어야 할 후행 조건으로 구성된다.

선행 조건은 전제(given)을, 후행 조건은 결과(then)를 나타낸다. 시스템 작업 호출 시 먼저 선행 조건을 확인한 후, 후행 조건을 만족시키는 액션을 수행한다.

고수준 도메인 모델과 시스템 작업을 보면 애플리케이션이 무슨 일을 하는지 알 수 있기 때문에 아키텍처를 정의하는 데 대단히 유용하다.

### 2.2.2 서비스 정의: 비즈니스 능력 패턴별 분해

마이크로서비스 아키텍처를 구축하는 첫 번째 전략은 비즈니스 능력에 따라 분해하는 것이다. 비즈니스 아키텍처 모델링에서 비롯된 비즈니스 능력은 비즈니스가 가치를 생산하기 위해 하는 일을 말한다.

#### 비즈니스 능력은 곧 조직이 하는 일이다

비즈니스 능력을 보면 그 조직의 비즈니스가 무엇인지 알 수 있다.

#### 비즈니스 능력 식별

한 조직의 비즈니스 능력은 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별한다.

비즈니스 능력은 보통 특정 비즈니스 객체에 집중하며, 여러 개의 하위 능력으로 분해할 수 있다.

#### 비즈니스 능력을 여러 서비스로

비즈니스 능력을 식별한 후 능력에 따라 또는 연관된 능력 그룹에 따라 서비스를 정의한다.

서비스를 거의 변하지 않는 비즈니스 능력에 따라 구성하면 비교적 안정적인 아키텍처를 구축할 수 있다.

가령 IPC가 너무 잦아 분해하는 것이 외려 비효율적이라서 서비스를 분해하는 경우, 반대로 어떤 서비스는 여러 개의 서비스로 나누는 것이 더 나을 정도로 복잡해지는 경우도 있다.

### 2.2.3 서비스 정의: 하위 도메인 패턴별 분해

DDD는 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 애플리케이션을 구축하는 방법이다. 도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링하는 기법이다. DDD에는 마이크로서비스 아키텍처에 적용하면 정말 유용한 하위 도메인과 경계 컨텍스트 개념이 있다.

DDD는 범위가 분명한 도메인 모델을 여러 개 정의하여 기존 방식의 문제점을 해결하는 전혀 다른 방식의 모델링이다.

DDD는 도메인을 구성하는 각 하위 도메인(애플리케이션의 problem space를 가리키는 DDD용어)마다 도메인 모델을 따로 정의한다.

도메인 모델의 범위를 DDD 용어로는 경계 컨텍스트라고 한다. 경계 컨텍스트는 도메인 모델을 구현한 코드 아티팩트를 포함하며, 미이크로서비스 아키텍처에 DDD를 적용하면 각 서비스가 경계 컨텍스트가 된다.

DDD의 하위 도메인, 경계 컨텍스트 개념은 마이크로서비스 아키텍처의 서비스와 잘 맞고, 마이크로서비스 아키텍처의 서비스 자율 팀 개념은 도메인 모델을 개별 팀이 소유/개발한다는 DDD 사고방식과 어울린다.

### 2.2.4 분해 지침

비즈니스 능력에 따른 분해, 하위 도메인에 따른 분해는 마이크로서비스 아키텍처를 정의하는 주요 수단이다.

#### 단일 책임 원칙(SRP)

소프트웨어 아키텍처/설계의 주요 목표 중 하나는 각 소프트웨어 엘리먼트의 책임을 할당하는 것이다. 단일 책임 원칙은 다음 한 문장으로 표현된다.

> 클래스는 오직 하나의 변경 사유를 가져야 한다. -로버트 C. 마틴

이 원칙을 마이크로서비스 아키텍처에 적용하면 하나의 책임만 가진 작고 응집된 서비스를 정의할 수 있다.

#### 공동 폐쇄 원칙(CCP)

**OCP(개방 폐쇄 원칙)와 다름**

> 패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지가 속한 모든 클래스에 영향을 끼친다. -로버트 C. 마틴

즉, 어떤 두 클래스가 동일한 사유로 맞물려 변경되면 동일한 패키지에 있어야 한다는 것이다. CCP를 잘 지키면 애플리케이션의 유지보수성이 현저히 향상된다.

CCP를 적용해서 마이크로서비스 아키텍처를 구축하면 동일한 사유로 변경되는 컴포넌트를 모두 같은 서비스로 묶을 수 있다.

### 2.2.5 서비스 분해의 장애물

#### 네트워크 지연

서비스를 여러 개로 나누면 서비스 간 왕복 횟수가 증가함. 한 차례 왕복으로 여러 객체를 한 번에 가져오는 배치 API를 구현하거나, 값비싼 IPC를 언어 수준의 메서드나 함수 호출로 대체하는 식으로 서비스 결합에 따른 지연 시간을 줄여야한다.

#### 동기 IPC로 인한 가용성 저하

비동기 메시징(3장)으로 강한 결합도를 제거하고 가용성을 높이는 방법이 있다.

#### 여러 서비스에 걸쳐 데이터 일관성 유지

과거에는 커밋 방식의 2단계(2PC) 분산 트랜잭션을 많이 썼지만, 요즘 애플리케이션에는 잘 안 맞기 때문에 사가라는 전혀 다른 방식으로 트랜잭션을 관리해야 한다. 사가는 메시징을 이용한 일련의 로컬 트랜잭션이다. 한 가지 단점은 최종 일관성(당장은 맞지 않지만 결국 언젠가는 동기화되어 일관성이 맞추어짐)을 보장한다는 것이다. 어떤 데이터를 원자적으로 업데이트해야 한다면 그 데이터를 하나의 서비스 내부에 두어야 하는데, 이는 결국 분해의 걸림돌이 된다.

#### 일관된 데이터 뷰 확보

모놀리식 애플리케이션에서는 ACID 트랜잭션의 속성 덕분에 어떻게 쿼리를 하든 일관된 데이터 뷰가 반환되지만, 마이크로서비스 아키텍처는 각 서비스의 DB가 일관적이라 해도 전역 범위에서 일관된 데이터 뷰는 확보할 수 없다. 어떤 데이터를 일관된 뷰로 바라보려면 하나의 서비스 내부에 두어야 하는데, 이 역시 분해의 걸림돌이 된다. 하지만 다행히 실제로 이것은 거의 문제가 되지 않는다.

#### 만능 클래스는 분해의 걸림돌

DDD를 적용하여 각 서비스를 자체 도메인 모델을 갖고 있는 개별 하위 도메인으로 취급하는 방법이 가장 좋은 방법.

### 2.2.6 서비스 API 정의

서비스 API 작업은 외부 클라이언트 또는 타 서비스가 호출하는 시스템 작업과 서비스간 협동을 지원하기 위해 타 서비스 호출 전용으로 만든 작업, 둘 중하나이다.

서비스 이벤트는 주로 타 서비스와 협동하기 위해 발행된다. 이벤트는 애플리케이션이 외부 웹 클라이언트에 알림을 보내는 용도로도 쓰인다(예: 웹 소켓을 통해 브라우저에 이벤트 전달).

#### 시스템 작업을 서비스로 배정

제일 먼저 어느 서비스가 요청의 진입점인지 결정해야 한다. 어떤 작업이 제공하는 정보가 필요한 서비스에 그 작업을 배정하는 것이 더 합리적이다.

시스템 작업을 각 서비스에 배정한 후, 각 시스템 작업을 처리하기 위해 서비스가 어떻게 협동해야 할지 정한다.

#### 서비스 간 협동 지원에 필요한 API 확정

서비스 하나로 전부 처리 가능한 시스템 작업도 있지만, 작업은 대부분 여러 서비스에 걸쳐 있다.

서비스별 작업에서 협동자를 추상적으로 스케치 한 **표 2-3 확인**

## 2.3 마치며

- 아키텍처는 애플리케이션 개발 속도에 직접 영향을 주는 갖가지 '~성'을 좌우한다(예: 관리성, 테스트성, 배포성).
- 마이크로서비스 아키텍처는 애플리케이션의 관리성, 테스트성, 배포성을 높이는 아키텍처 스타일이다.
- 마이크로서비스는 기술적 관심사보다 비즈니스 능력, 하위 도메인 등 비즈니스 관심사 위주로 구성된다.
- 서비스를 분해하는 패턴은 크게 두 가지이다.
  - 비즈니스 능력에 따른 분해: 비즈니스 아키텍처 기반
  - 하위 도메인에 따른 분해: DDD 개념 기반
- DDD를 적용하고 서비스마다 도메인 모델을 따로 설계하면, 의존 관계가 뒤엉켜 분해를 가로막는 만능 클래스를 제거할 수 있다.

 