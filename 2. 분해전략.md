# 분해 전략

### 이 장에서 다룰 핵심 내용

- 소프트웨어 아키텍처의 정의와 중요성
- 분해 패턴을 적용하여 비즈니스 능력 및 하위 도메인별로 애플리케이션을 섭스로 분해
- DDD의 경계 컨텍스트 개념을 활용하여 복잡하게 얽힌 데이터를 분해하기 더 쉽게 풀기

마이크로서비스 아키텍처의 핵심과제는 애플리케이션을 기능에 따라 여러 서비스로 분해하는 문제이다. 결국 이 아키텍처의 출발점이자, 가장 중요한 요소는 서비스를 어떻게 정의하느냐 하는 것이다.

## 2.1 마이크로서비스 아키텍처란 무엇인가?

아키텍쳐가 중요한 이유는 소프트웨어의 품질 속성, 즉 '~성(~ilities)'으로 끝나는 지표가 아키텍처에 의해 결정되기 때문이다. 곧 배우는 마이크로서비스 아키텍처는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍처 스타일이다.

### 2.1.1 소프트웨어 아키텍처의 정의와 중요성

#### 소프트웨어 아키텍처의 정의

Len Bass와 그가 이끄는 소프트웨어 공학 연구소 직원들이 내린 정의를 참고하자면 다음과 같다.

> 컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트와 그들 간의 관계 그리고 이 둘의 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다.

다소 추상적인 문구이지만, 핵심은 애플리케이션 아키텍처가 여러 파트(엘리먼트)로의 분해와 이런 파트 간의 관계(연관성)라는 것이다. 분해가 중요한 이유는 다음 두 가지와 같다.

- 업무(labor)와 지식(knowledge)을 분리한다. 덕분에 전문 지식을 보유한 사람들(또는 여러 팀)이 함께 생산적으로 애플리케이션 작업을 할 수 있다.
- 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힌다.

#### 소프트웨어 아키텍처의 4+1 뷰 모델

Phillip Krutchen은 소프트웨어 아키텍처가 4+1 이라고 기술한 논문을 발표 했다. 4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의한다. 각 뷰는 아키텍처의 특정한 측면을 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.

**그림 2-1 확인**

각 뷰의 목적은 다음과 같다.

- 논리 뷰(logical view): 개발자가 작성한 소프트웨어 엘리먼트, 객체 지향 언어라면 클래스 패키지가 해당되며 결국 상속(inheritance), 연관(association), 의존(depends-on) 등 클래스와 패키지의 관계를 말한다.
- 구현 뷰(implementation view): 빌드 시스템의 결과물, 모듈(패키징된 코드)과 컴포넌트(하나 이상의 모듈로 구성된 실행/배포 가능 단위)로 구성된다. 자바에서 모듈은 보통 JAR 파일, 컴포넌트는 WAR 파일이나 실행 가능한 JAR 파일이다. 모듈 간 디펜던시와 컴포넌트/모듈 간 조합 관계도 이 뷰에 포함된다.
- 프로세스 뷰(process view): 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고, **[IPC](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=green187&logNo=110130416319)**는 프로세스 간 관계를 나타낸다.
- 배포 뷰(deployment view): 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 (물리 또는 가상) 머신 및 프로세스고, 머신 간의 관계가 바로 네트워킹이다. 프로세스와 머신사이의 관계도 이 뷰에서 기술된다.

4뷰 외에도 뷰를 구동시키는 시나리오가 있다. 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술한다.

정리하자면, 4+1 뷰 모델은 애플리케이션 아키텍처를 명쾌하게 표현하는 수단이다. 4뷰는 중요한 아키텍처 측면을, 시나리오는 뷰의 여러 엘리먼트가 협동하는 과정을 명시한다.

#### 아키텍처의 중요성

애플리케이션 요건은 크게 두 가지 종류로 나뉜다. 첫째, 애플리케이션이 해야 할 일을 정의한 기능 요건이다. 이 기능 요건과 아키텍처는 거의 무관하다. 어느 아키텍처든 기능 구현은 가능하기 때문!

둘째, 이른바 '~성'으로 끝나는 서비스 품질 요건이다. 아키텍처는 바로 이 요건을 충족시킬 수 있게 설계해야 하므로 아주 중요하다. 서비스 품질 요건은 확장성, 신뢰성 같은 런타임 품질 외에도 관리성, 테스트성, 베포성처럼 개발 시점의 품질도 해당된다. 애플리케이션 아키텍처를 어떻게 선택하느냐에 따라 이런 품질 요건을 얼마나 충족할 수 있을지 결정된다.

### 2.1.2 아키텍처 스타일 개요

소프트웨어 아키텍처 지식 체계의 선구자인 David Garlan과 Mary Shaw는 아키텍처 스타일을 이렇게 정의한다고 한다.

> 아키텍처 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다. 좀 더 구체적으로 말하면, 아키텍처 스타일은 그 스타일로 만든 인스턴스에서 사용 가능한 컴포넌트와 커넥터의 vocabulary(용어집), 그리고 이들을 조합할 수 있는 제약 조건을 결정한다.

| 아키텍처       | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| 모놀리식       | 구현 뷰를 하나의 컴포넌트로 구성한 아키텍처 스타일           |
| 마이크로서비스 | 애플리케이션을 느슨하게 결합된 여러 서비스로 구성하는 아키텍처 스타일 |

#### 계층화 아키텍처 스타일

계층마다 명확히 정의된 역할을 분담하여, 계층간 디펜던시는 아키텍처로 제한한다. 따라서 어떤 계층은 바로 하위에 있는 계층에만 의존하거나, 하위에 위치한 어느 한 계층에 의존한다.

3계층 아키텍처가 바로 계층화 아키텍처를 논리 뷰에 적용한 사례로, 애플리케이션 클래스를 다음 세 계층으로 구성한 아키텍처이다.

- 표현 계층(presentation layer): 사용자 인터페이스 또는 외부 API가 구현된 계층
- 비즈니스 로직 계층(business logic layer): 비즈니스 로직이 구현된 계층
- 영속화 계층(persistence layer): DB 상호 작용 로직이 구현된 계층

하지만 계층화 아키텍처는 몇 가지 중요한 흠이 있다.

- 표현 계층이 하나뿐이다: 애플리케이션을 호출하는 시스템이 하나밖에 없을까?
- 영속화 계층이 하나뿐이다: 애플리케이션이 상호작용하는 DB가 정말 하나뿐일까?
- 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다: 이론적으로 이런 디펜던시 때문에 DB 없이 비즈니스 로직을 테스트하는 것은 불가능하다.

육각형 아키텍처는 이런 문제점을 해결하고자 고안되었다.

#### 육각형 아키텍처 스타일

**그림 2-2 확인**

육각형 아키텍처는 논리 뷰를 비즈니스 로직 중심으로 구성한다. 애플리케이션에 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터들과 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터들을 둔다. 비즈니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 이 아키텍처의 가장 중요한 특장점이다.

비즈니스 로직에는 하나 이상의 포트가 있다. 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된 작업이다. 가령 자바라면 인터페이스가 포트. 포트 종류는 인바운드/아웃바운드 두 가지이다. 인바운드 포트는 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을 호출한다(예: 서비스의 퍼블릭 메서드가 정의된 서비스 인터페이스). 아웃바운드 포트는 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것이다(예: 데이터 접근 작업이 정의된 repository interface).